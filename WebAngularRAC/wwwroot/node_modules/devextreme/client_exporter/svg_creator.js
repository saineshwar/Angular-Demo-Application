/**
 * DevExtreme (client_exporter/svg_creator.js)
 * Version: 17.1.3
 * Build date: Wed May 17 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
var $ = require("../core/renderer"),
    commonUtils = require("../core/utils/common"),
    getSvgMarkup = require("../core/utils/svg").getSvgMarkup,
    when = require("../integration/jquery/deferred").when;
exports.svgCreator = {
    _markup: "",
    _imageArray: {},
    _imageDeferreds: [],
    _getBinaryFile: function(src, callback) {
        var xhr = new XMLHttpRequest;
        xhr.onreadystatechange = function() {
            if (xhr.readyState === xhr.DONE) {
                if (200 === xhr.status && xhr.response) {
                    callback(xhr.response)
                } else {
                    callback(false)
                }
            }
        };
        xhr.open("GET", src, true);
        xhr.responseType = "arraybuffer";
        xhr.send()
    },
    _loadImages: function() {
        var that = this;
        $.each(that._imageArray, function(src) {
            var deferred = new $.Deferred;
            that._imageDeferreds.push(deferred);
            that._getBinaryFile(src, function(response) {
                if (!response) {
                    delete that._imageArray[src];
                    deferred.resolve();
                    return
                }
                var i, binary = "",
                    bytes = new Uint8Array(response),
                    length = bytes.byteLength;
                for (i = 0; i < length; i++) {
                    binary += String.fromCharCode(bytes[i])
                }
                that._imageArray[src] = "data:image/png;base64," + btoa(binary);
                deferred.resolve()
            })
        })
    },
    _parseImages: function(element) {
        var href, that = this;
        if ("image" === element.tagName) {
            href = $(element).attr("xlink:href");
            if (!that._imageArray[href]) {
                that._imageArray[href] = ""
            }
        }
        $.each(element.childNodes, function(_, element) {
            that._parseImages(element)
        })
    },
    _prepareImages: function(svgElem) {
        this._parseImages(svgElem);
        this._loadImages();
        return when.apply($, this._imageDeferreds)
    },
    getData: function(data, options) {
        var markup, that = this,
            xmlVersion = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>',
            blob = $.Deferred(),
            parser = new DOMParser,
            elem = parser.parseFromString(data, "image/svg+xml"),
            svgElem = elem.childNodes[0],
            $svgObject = $(svgElem);
        $svgObject.css("background-color", options.backgroundColor);
        markup = xmlVersion + getSvgMarkup($svgObject.get(0));
        that._prepareImages(svgElem).done(function() {
            $.each(that._imageArray, function(href, dataURI) {
                markup = markup.split(href).join(dataURI)
            });
            blob.resolve(commonUtils.isFunction(window.Blob) ? that._getBlob(markup) : that._getBase64(markup))
        });
        return blob
    },
    _getBlob: function(markup) {
        return new Blob([markup], {
            type: "image/svg+xml"
        })
    },
    _getBase64: function(markup) {
        return window.btoa(markup)
    }
};
exports.getData = function(data, options, callback) {
    exports.svgCreator.getData(data, options).done(callback)
};
